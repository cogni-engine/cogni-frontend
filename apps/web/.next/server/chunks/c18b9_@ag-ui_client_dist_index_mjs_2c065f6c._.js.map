{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/air13/code/cogni/cogni-frontend/node_modules/.pnpm/%40ag-ui%2Bclient%400.0.39/node_modules/%40ag-ui/client/src/apply/default.ts","file:///Users/air13/code/cogni/cogni-frontend/node_modules/.pnpm/%40ag-ui%2Bclient%400.0.39/node_modules/%40ag-ui/client/src/utils.ts","file:///Users/air13/code/cogni/cogni-frontend/node_modules/.pnpm/%40ag-ui%2Bclient%400.0.39/node_modules/%40ag-ui/client/src/agent/subscriber.ts","file:///Users/air13/code/cogni/cogni-frontend/node_modules/.pnpm/%40ag-ui%2Bclient%400.0.39/node_modules/%40ag-ui/client/src/verify/verify.ts","file:///Users/air13/code/cogni/cogni-frontend/node_modules/.pnpm/%40ag-ui%2Bclient%400.0.39/node_modules/%40ag-ui/client/src/transform/http.ts","file:///Users/air13/code/cogni/cogni-frontend/node_modules/.pnpm/%40ag-ui%2Bclient%400.0.39/node_modules/%40ag-ui/client/src/run/http-request.ts","file:///Users/air13/code/cogni/cogni-frontend/node_modules/.pnpm/%40ag-ui%2Bclient%400.0.39/node_modules/%40ag-ui/client/src/transform/sse.ts","file:///Users/air13/code/cogni/cogni-frontend/node_modules/.pnpm/%40ag-ui%2Bclient%400.0.39/node_modules/%40ag-ui/client/src/transform/proto.ts","file:///Users/air13/code/cogni/cogni-frontend/node_modules/.pnpm/%40ag-ui%2Bclient%400.0.39/node_modules/%40ag-ui/client/src/legacy/convert.ts","file:///Users/air13/code/cogni/cogni-frontend/node_modules/.pnpm/%40ag-ui%2Bclient%400.0.39/node_modules/%40ag-ui/client/src/legacy/types.ts","file:///Users/air13/code/cogni/cogni-frontend/node_modules/.pnpm/%40ag-ui%2Bclient%400.0.39/node_modules/%40ag-ui/client/src/agent/agent.ts","file:///Users/air13/code/cogni/cogni-frontend/node_modules/.pnpm/%40ag-ui%2Bclient%400.0.39/node_modules/%40ag-ui/client/src/chunks/transform.ts","file:///Users/air13/code/cogni/cogni-frontend/node_modules/.pnpm/%40ag-ui%2Bclient%400.0.39/node_modules/%40ag-ui/client/src/agent/http.ts","file:///Users/air13/code/cogni/cogni-frontend/node_modules/.pnpm/%40ag-ui%2Bclient%400.0.39/node_modules/%40ag-ui/client/src/index.ts"],"sourcesContent":["import {\n  EventType,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  Message,\n  DeveloperMessage,\n  SystemMessage,\n  AssistantMessage,\n  UserMessage,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  StateSnapshotEvent,\n  StateDeltaEvent,\n  MessagesSnapshotEvent,\n  CustomEvent,\n  BaseEvent,\n  ToolCallResultEvent,\n  ToolMessage,\n  RunAgentInput,\n  TextMessageEndEvent,\n  ToolCallEndEvent,\n  RawEvent,\n  RunStartedEvent,\n  RunFinishedEvent,\n  RunErrorEvent,\n  StepStartedEvent,\n  StepFinishedEvent,\n} from \"@ag-ui/core\";\nimport { mergeMap, mergeAll, defaultIfEmpty, concatMap } from \"rxjs/operators\";\nimport { of, EMPTY } from \"rxjs\";\nimport { structuredClone_ } from \"../utils\";\nimport { applyPatch } from \"fast-json-patch\";\nimport {\n  AgentStateMutation,\n  AgentSubscriber,\n  runSubscribersWithMutation,\n} from \"@/agent/subscriber\";\nimport { Observable } from \"rxjs\";\nimport { AbstractAgent } from \"@/agent/agent\";\nimport untruncateJson from \"untruncate-json\";\n\nexport const defaultApplyEvents = (\n  input: RunAgentInput,\n  events$: Observable<BaseEvent>,\n  agent: AbstractAgent,\n  subscribers: AgentSubscriber[],\n): Observable<AgentStateMutation> => {\n  let messages = structuredClone_(input.messages);\n  let state = structuredClone_(input.state);\n  let currentMutation: AgentStateMutation = {};\n\n  const applyMutation = (mutation: AgentStateMutation) => {\n    if (mutation.messages !== undefined) {\n      messages = mutation.messages;\n      currentMutation.messages = mutation.messages;\n    }\n    if (mutation.state !== undefined) {\n      state = mutation.state;\n      currentMutation.state = mutation.state;\n    }\n  };\n\n  const emitUpdates = () => {\n    const result = structuredClone_(currentMutation) as AgentStateMutation;\n    currentMutation = {};\n    if (result.messages !== undefined || result.state !== undefined) {\n      return of(result);\n    }\n    return EMPTY;\n  };\n\n  return events$.pipe(\n    concatMap(async (event) => {\n      const mutation = await runSubscribersWithMutation(\n        subscribers,\n        messages,\n        state,\n        (subscriber, messages, state) =>\n          subscriber.onEvent?.({ event, agent, input, messages, state }),\n      );\n      applyMutation(mutation);\n\n      if (mutation.stopPropagation === true) {\n        return emitUpdates();\n      }\n\n      switch (event.type) {\n        case EventType.TEXT_MESSAGE_START: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageStartEvent?.({\n                event: event as TextMessageStartEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messageId, role = \"assistant\" } = event as TextMessageStartEvent;\n\n            // Create a new message using properties from the event\n            // Text messages can be developer, system, assistant, or user (not tool)\n            const newMessage: Message = {\n              id: messageId,\n              role: role,\n              content: \"\",\n            };\n\n            // Add the new message to the messages array\n            messages.push(newMessage);\n            applyMutation({ messages });\n          }\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_CONTENT: {\n          const { messageId, delta } = event as TextMessageContentEvent;\n\n          // Find the target message by ID\n          const targetMessage = messages.find((m) => m.id === messageId);\n          if (!targetMessage) {\n            console.warn(`TEXT_MESSAGE_CONTENT: No message found with ID '${messageId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageContentEvent?.({\n                event: event as TextMessageContentEvent,\n                messages,\n                state,\n                agent,\n                input,\n                textMessageBuffer: targetMessage.content ?? \"\",\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            // Append content to the correct message by ID\n            targetMessage.content = (targetMessage.content || \"\") + delta;\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_END: {\n          const { messageId } = event as TextMessageEndEvent;\n\n          // Find the target message by ID\n          const targetMessage = messages.find((m) => m.id === messageId);\n          if (!targetMessage) {\n            console.warn(`TEXT_MESSAGE_END: No message found with ID '${messageId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageEndEvent?.({\n                event: event as TextMessageEndEvent,\n                messages,\n                state,\n                agent,\n                input,\n                textMessageBuffer: targetMessage.content ?? \"\",\n              }),\n          );\n          applyMutation(mutation);\n\n          await Promise.all(\n            subscribers.map((subscriber) => {\n              subscriber.onNewMessage?.({\n                message: targetMessage,\n                messages,\n                state,\n                agent,\n                input,\n              });\n            }),\n          );\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_START: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onToolCallStartEvent?.({\n                event: event as ToolCallStartEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { toolCallId, toolCallName, parentMessageId } = event as ToolCallStartEvent;\n\n            let targetMessage: AssistantMessage;\n\n            // Use last message if parentMessageId exists, we have messages, and the parentMessageId matches the last message's id\n            if (\n              parentMessageId &&\n              messages.length > 0 &&\n              messages[messages.length - 1].id === parentMessageId\n            ) {\n              targetMessage = messages[messages.length - 1] as AssistantMessage;\n            } else {\n              // Create a new message otherwise\n              targetMessage = {\n                id: parentMessageId || toolCallId,\n                role: \"assistant\",\n                toolCalls: [],\n              };\n              messages.push(targetMessage);\n            }\n\n            targetMessage.toolCalls ??= [];\n\n            // Add the new tool call\n            targetMessage.toolCalls.push({\n              id: toolCallId,\n              type: \"function\",\n              function: {\n                name: toolCallName,\n                arguments: \"\",\n              },\n            });\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_ARGS: {\n          const { toolCallId, delta } = event as ToolCallArgsEvent;\n\n          // Find the message containing this tool call\n          const targetMessage = messages.find((m) =>\n            (m as AssistantMessage).toolCalls?.some((tc) => tc.id === toolCallId),\n          ) as AssistantMessage;\n\n          if (!targetMessage) {\n            console.warn(\n              `TOOL_CALL_ARGS: No message found containing tool call with ID '${toolCallId}'`,\n            );\n            return emitUpdates();\n          }\n\n          // Find the specific tool call\n          const targetToolCall = targetMessage.toolCalls!.find((tc) => tc.id === toolCallId);\n          if (!targetToolCall) {\n            console.warn(`TOOL_CALL_ARGS: No tool call found with ID '${toolCallId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) => {\n              const toolCallBuffer = targetToolCall.function.arguments;\n              const toolCallName = targetToolCall.function.name;\n              let partialToolCallArgs = {};\n              try {\n                // Parse from toolCallBuffer only (before current delta is applied)\n                partialToolCallArgs = untruncateJson(toolCallBuffer);\n              } catch (error) {}\n\n              return subscriber.onToolCallArgsEvent?.({\n                event: event as ToolCallArgsEvent,\n                messages,\n                state,\n                agent,\n                input,\n                toolCallBuffer,\n                toolCallName,\n                partialToolCallArgs,\n              });\n            },\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            // Append the arguments to the correct tool call by ID\n            targetToolCall.function.arguments += delta;\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_END: {\n          const { toolCallId } = event as ToolCallEndEvent;\n\n          // Find the message containing this tool call\n          const targetMessage = messages.find((m) =>\n            (m as AssistantMessage).toolCalls?.some((tc) => tc.id === toolCallId),\n          ) as AssistantMessage;\n\n          if (!targetMessage) {\n            console.warn(\n              `TOOL_CALL_END: No message found containing tool call with ID '${toolCallId}'`,\n            );\n            return emitUpdates();\n          }\n\n          // Find the specific tool call\n          const targetToolCall = targetMessage.toolCalls!.find((tc) => tc.id === toolCallId);\n          if (!targetToolCall) {\n            console.warn(`TOOL_CALL_END: No tool call found with ID '${toolCallId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) => {\n              const toolCallArgsString = targetToolCall.function.arguments;\n              const toolCallName = targetToolCall.function.name;\n              let toolCallArgs = {};\n              try {\n                toolCallArgs = JSON.parse(toolCallArgsString);\n              } catch (error) {}\n              return subscriber.onToolCallEndEvent?.({\n                event: event as ToolCallEndEvent,\n                messages,\n                state,\n                agent,\n                input,\n                toolCallName,\n                toolCallArgs,\n              });\n            },\n          );\n          applyMutation(mutation);\n\n          await Promise.all(\n            subscribers.map((subscriber) => {\n              subscriber.onNewToolCall?.({\n                toolCall: targetToolCall,\n                messages,\n                state,\n                agent,\n                input,\n              });\n            }),\n          );\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_RESULT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onToolCallResultEvent?.({\n                event: event as ToolCallResultEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messageId, toolCallId, content, role } = event as ToolCallResultEvent;\n\n            const toolMessage: ToolMessage = {\n              id: messageId,\n              toolCallId,\n              role: role || \"tool\",\n              content: content,\n            };\n\n            messages.push(toolMessage);\n\n            await Promise.all(\n              subscribers.map((subscriber) => {\n                subscriber.onNewMessage?.({\n                  message: toolMessage,\n                  messages,\n                  state,\n                  agent,\n                  input,\n                });\n              }),\n            );\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.STATE_SNAPSHOT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStateSnapshotEvent?.({\n                event: event as StateSnapshotEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { snapshot } = event as StateSnapshotEvent;\n\n            // Replace state with the literal snapshot\n            state = snapshot;\n\n            applyMutation({ state });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.STATE_DELTA: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStateDeltaEvent?.({\n                event: event as StateDeltaEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { delta } = event as StateDeltaEvent;\n\n            try {\n              // Apply the JSON Patch operations to the current state without mutating the original\n              const result = applyPatch(state, delta, true, false);\n              state = result.newDocument;\n              applyMutation({ state });\n            } catch (error: unknown) {\n              const errorMessage = error instanceof Error ? error.message : String(error);\n              console.warn(\n                `Failed to apply state patch:\\n` +\n                  `Current state: ${JSON.stringify(state, null, 2)}\\n` +\n                  `Patch operations: ${JSON.stringify(delta, null, 2)}\\n` +\n                  `Error: ${errorMessage}`,\n              );\n              // If patch failed, only emit updates if there were subscriber mutations\n              // This prevents emitting updates when both patch fails AND no subscriber mutations\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.MESSAGES_SNAPSHOT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onMessagesSnapshotEvent?.({\n                event: event as MessagesSnapshotEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messages: newMessages } = event as MessagesSnapshotEvent;\n\n            // Replace messages with the snapshot\n            messages = newMessages;\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.RAW: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRawEvent?.({\n                event: event as RawEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.CUSTOM: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onCustomEvent?.({\n                event: event as CustomEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_STARTED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunStartedEvent?.({\n                event: event as RunStartedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_FINISHED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunFinishedEvent?.({\n                event: event as RunFinishedEvent,\n                messages,\n                state,\n                agent,\n                input,\n                result: (event as RunFinishedEvent).result,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_ERROR: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunErrorEvent?.({\n                event: event as RunErrorEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.STEP_STARTED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStepStartedEvent?.({\n                event: event as StepStartedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.STEP_FINISHED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStepFinishedEvent?.({\n                event: event as StepFinishedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_CHUNK: {\n          throw new Error(\"TEXT_MESSAGE_CHUNK must be tranformed before being applied\");\n        }\n\n        case EventType.TOOL_CALL_CHUNK: {\n          throw new Error(\"TOOL_CALL_CHUNK must be tranformed before being applied\");\n        }\n\n        case EventType.THINKING_START: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_END: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_START: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_CONTENT: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_END: {\n          return emitUpdates();\n        }\n      }\n\n      // This makes TypeScript check that the switch is exhaustive\n      // If a new EventType is added, this will cause a compile error\n      const _exhaustiveCheck: never = event.type;\n      return emitUpdates();\n    }),\n    mergeAll(),\n    // Only use defaultIfEmpty when there are subscribers to avoid emitting empty updates\n    // when patches fail and there are no subscribers (like in state patching test)\n    subscribers.length > 0 ? defaultIfEmpty({} as AgentStateMutation) : (stream: any) => stream,\n  );\n};\n","export const structuredClone_ = <T>(obj: T): T => {\n  if (typeof structuredClone === \"function\") {\n    return structuredClone(obj);\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(obj));\n  } catch (err) {\n    return { ...obj } as T;\n  }\n};\n","import {\n  BaseEvent,\n  Message,\n  RunAgentInput,\n  RunErrorEvent,\n  RunFinishedEvent,\n  RunStartedEvent,\n  State,\n  StateDeltaEvent,\n  StateSnapshotEvent,\n  StepFinishedEvent,\n  StepStartedEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  TextMessageStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  ToolCallStartEvent,\n  MessagesSnapshotEvent,\n  RawEvent,\n  CustomEvent,\n  ToolCall,\n} from \"@ag-ui/core\";\nimport { AbstractAgent } from \"./agent\";\nimport { structuredClone_ } from \"@/utils\";\n\nexport interface AgentStateMutation {\n  messages?: Message[];\n  state?: State;\n  stopPropagation?: boolean;\n}\n\nexport interface AgentSubscriberParams {\n  messages: Message[];\n  state: State;\n  agent: AbstractAgent;\n  input: RunAgentInput;\n}\n\n// Utility type to allow callbacks to be implemented either synchronously or asynchronously.\nexport type MaybePromise<T> = T | Promise<T>;\n\nexport interface AgentSubscriber {\n  // Request lifecycle\n  onRunInitialized?(\n    params: AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n  onRunFailed?(\n    params: { error: Error } & AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n  onRunFinalized?(\n    params: AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n\n  // Events\n  onEvent?(\n    params: { event: BaseEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onRunStartedEvent?(\n    params: { event: RunStartedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onRunFinishedEvent?(\n    params: { event: RunFinishedEvent; result?: any } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onRunErrorEvent?(\n    params: { event: RunErrorEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStepStartedEvent?(\n    params: { event: StepStartedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onStepFinishedEvent?(\n    params: { event: StepFinishedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onTextMessageStartEvent?(\n    params: { event: TextMessageStartEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onTextMessageContentEvent?(\n    params: {\n      event: TextMessageContentEvent;\n      textMessageBuffer: string;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onTextMessageEndEvent?(\n    params: { event: TextMessageEndEvent; textMessageBuffer: string } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onToolCallStartEvent?(\n    params: { event: ToolCallStartEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onToolCallArgsEvent?(\n    params: {\n      event: ToolCallArgsEvent;\n      toolCallBuffer: string;\n      toolCallName: string;\n      partialToolCallArgs: Record<string, any>;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onToolCallEndEvent?(\n    params: {\n      event: ToolCallEndEvent;\n      toolCallName: string;\n      toolCallArgs: Record<string, any>;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onToolCallResultEvent?(\n    params: { event: ToolCallResultEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStateSnapshotEvent?(\n    params: { event: StateSnapshotEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStateDeltaEvent?(\n    params: { event: StateDeltaEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onMessagesSnapshotEvent?(\n    params: { event: MessagesSnapshotEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onRawEvent?(\n    params: { event: RawEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onCustomEvent?(\n    params: { event: CustomEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  // State changes\n  onMessagesChanged?(\n    params: Omit<AgentSubscriberParams, \"input\"> & { input?: RunAgentInput },\n  ): MaybePromise<void>;\n  onStateChanged?(\n    params: Omit<AgentSubscriberParams, \"input\"> & { input?: RunAgentInput },\n  ): MaybePromise<void>;\n  onNewMessage?(\n    params: { message: Message } & Omit<AgentSubscriberParams, \"input\"> & {\n        input?: RunAgentInput;\n      },\n  ): MaybePromise<void>;\n  onNewToolCall?(\n    params: { toolCall: ToolCall } & Omit<AgentSubscriberParams, \"input\"> & {\n        input?: RunAgentInput;\n      },\n  ): MaybePromise<void>;\n}\n\nexport async function runSubscribersWithMutation(\n  subscribers: AgentSubscriber[],\n  initialMessages: Message[],\n  initialState: State,\n  executor: (\n    subscriber: AgentSubscriber,\n    messages: Message[],\n    state: State,\n  ) => MaybePromise<AgentStateMutation | void>,\n): Promise<AgentStateMutation> {\n  let messages: Message[] = initialMessages;\n  let state: State = initialState;\n\n  let stopPropagation: boolean | undefined = undefined;\n\n  for (const subscriber of subscribers) {\n    try {\n      const mutation = await executor(\n        subscriber,\n        structuredClone_(messages),\n        structuredClone_(state),\n      );\n\n      if (mutation === undefined) {\n        // Nothing returned â€“ keep going\n        continue;\n      }\n\n      // Merge messages/state so next subscriber sees latest view\n      if (mutation.messages !== undefined) {\n        messages = mutation.messages;\n      }\n\n      if (mutation.state !== undefined) {\n        state = mutation.state;\n      }\n\n      stopPropagation = mutation.stopPropagation;\n\n      if (stopPropagation === true) {\n        break;\n      }\n    } catch (error) {\n      // Log subscriber errors but continue processing (silence during tests)\n      const isTestEnvironment =\n        process.env.NODE_ENV === \"test\" || process.env.JEST_WORKER_ID !== undefined;\n\n      if (!isTestEnvironment) {\n        console.error(\"Subscriber error:\", error);\n      }\n      // Continue to next subscriber unless we want to stop propagation\n      continue;\n    }\n  }\n\n  return {\n    ...(JSON.stringify(messages) !== JSON.stringify(initialMessages) ? { messages } : {}),\n    ...(JSON.stringify(state) !== JSON.stringify(initialState) ? { state } : {}),\n    ...(stopPropagation !== undefined ? { stopPropagation } : {}),\n  };\n}\n","import { BaseEvent, EventType, AGUIError } from \"@ag-ui/core\";\nimport { Observable, throwError, of } from \"rxjs\";\nimport { mergeMap } from \"rxjs/operators\";\n\nexport const verifyEvents =\n  (debug: boolean) =>\n  (source$: Observable<BaseEvent>): Observable<BaseEvent> => {\n    // Declare variables in closure to maintain state across events\n    let activeMessages = new Map<string, boolean>(); // Map of message ID -> active status\n    let activeToolCalls = new Map<string, boolean>(); // Map of tool call ID -> active status\n    let runFinished = false;\n    let runError = false; // New flag to track if RUN_ERROR has been sent\n    // New flags to track first/last event requirements\n    let firstEventReceived = false;\n    // Track active steps\n    let activeSteps = new Map<string, boolean>(); // Map of step name -> active status\n    let activeThinkingStep = false;\n    let activeThinkingStepMessage = false;\n    let runStarted = false; // Track if a run has started\n\n    // Function to reset state for a new run\n    const resetRunState = () => {\n      activeMessages.clear();\n      activeToolCalls.clear();\n      activeSteps.clear();\n      activeThinkingStep = false;\n      activeThinkingStepMessage = false;\n      runFinished = false;\n      runError = false;\n      runStarted = true;\n    };\n\n    return source$.pipe(\n      // Process each event through our state machine\n      mergeMap((event) => {\n        const eventType = event.type;\n\n        if (debug) {\n          console.debug(\"[VERIFY]:\", JSON.stringify(event));\n        }\n\n        // Check if run has errored\n        if (runError) {\n          return throwError(\n            () =>\n              new AGUIError(\n                `Cannot send event type '${eventType}': The run has already errored with 'RUN_ERROR'. No further events can be sent.`,\n              ),\n          );\n        }\n\n        // Check if run has already finished (but allow new RUN_STARTED to start a new run)\n        if (runFinished && eventType !== EventType.RUN_ERROR && eventType !== EventType.RUN_STARTED) {\n          return throwError(\n            () =>\n              new AGUIError(\n                `Cannot send event type '${eventType}': The run has already finished with 'RUN_FINISHED'. Start a new run with 'RUN_STARTED'.`,\n              ),\n          );\n        }\n\n        // Handle first event requirement and sequential RUN_STARTED\n        if (!firstEventReceived) {\n          firstEventReceived = true;\n          if (eventType !== EventType.RUN_STARTED && eventType !== EventType.RUN_ERROR) {\n            return throwError(() => new AGUIError(`First event must be 'RUN_STARTED'`));\n          }\n        } else if (eventType === EventType.RUN_STARTED) {\n          // Allow RUN_STARTED after RUN_FINISHED (new run), but not during an active run\n          if (runStarted && !runFinished) {\n            return throwError(\n              () =>\n                new AGUIError(\n                  `Cannot send 'RUN_STARTED' while a run is still active. The previous run must be finished with 'RUN_FINISHED' before starting a new run.`,\n                ),\n            );\n          }\n          // If we're here, it's either the first RUN_STARTED or a new run after RUN_FINISHED\n          if (runFinished) {\n            // This is a new run after the previous one finished, reset state\n            resetRunState();\n          }\n        }\n\n        // Validate event based on type and current state\n        switch (eventType) {\n          // Text message flow\n          case EventType.TEXT_MESSAGE_START: {\n            const messageId = (event as any).messageId;\n\n            // Check if this message is already in progress\n            if (activeMessages.has(messageId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_START' event: A text message with ID '${messageId}' is already in progress. Complete it with 'TEXT_MESSAGE_END' first.`,\n                  ),\n              );\n            }\n\n            activeMessages.set(messageId, true);\n            return of(event);\n          }\n\n          case EventType.TEXT_MESSAGE_CONTENT: {\n            const messageId = (event as any).messageId;\n\n            // Must be in a message with this ID\n            if (!activeMessages.has(messageId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_CONTENT' event: No active text message found with ID '${messageId}'. Start a text message with 'TEXT_MESSAGE_START' first.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.TEXT_MESSAGE_END: {\n            const messageId = (event as any).messageId;\n\n            // Must be in a message with this ID\n            if (!activeMessages.has(messageId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_END' event: No active text message found with ID '${messageId}'. A 'TEXT_MESSAGE_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Remove message from active set\n            activeMessages.delete(messageId);\n            return of(event);\n          }\n\n          // Tool call flow\n          case EventType.TOOL_CALL_START: {\n            const toolCallId = (event as any).toolCallId;\n\n            // Check if this tool call is already in progress\n            if (activeToolCalls.has(toolCallId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_START' event: A tool call with ID '${toolCallId}' is already in progress. Complete it with 'TOOL_CALL_END' first.`,\n                  ),\n              );\n            }\n\n            activeToolCalls.set(toolCallId, true);\n            return of(event);\n          }\n\n          case EventType.TOOL_CALL_ARGS: {\n            const toolCallId = (event as any).toolCallId;\n\n            // Must be in a tool call with this ID\n            if (!activeToolCalls.has(toolCallId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_ARGS' event: No active tool call found with ID '${toolCallId}'. Start a tool call with 'TOOL_CALL_START' first.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.TOOL_CALL_END: {\n            const toolCallId = (event as any).toolCallId;\n\n            // Must be in a tool call with this ID\n            if (!activeToolCalls.has(toolCallId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_END' event: No active tool call found with ID '${toolCallId}'. A 'TOOL_CALL_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Remove tool call from active set\n            activeToolCalls.delete(toolCallId);\n            return of(event);\n          }\n\n          // Step flow\n          case EventType.STEP_STARTED: {\n            const stepName = (event as any).stepName;\n            if (activeSteps.has(stepName)) {\n              return throwError(\n                () => new AGUIError(`Step \"${stepName}\" is already active for 'STEP_STARTED'`),\n              );\n            }\n            activeSteps.set(stepName, true);\n            return of(event);\n          }\n\n          case EventType.STEP_FINISHED: {\n            const stepName = (event as any).stepName;\n            if (!activeSteps.has(stepName)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'STEP_FINISHED' for step \"${stepName}\" that was not started`,\n                  ),\n              );\n            }\n            activeSteps.delete(stepName);\n            return of(event);\n          }\n\n          // Run flow\n          case EventType.RUN_STARTED: {\n            // We've already validated this above\n            runStarted = true;\n            return of(event);\n          }\n\n          case EventType.RUN_FINISHED: {\n            // Can't be the first event (already checked)\n            // and can't happen after already being finished (already checked)\n\n            // Check that all steps are finished before run ends\n            if (activeSteps.size > 0) {\n              const unfinishedSteps = Array.from(activeSteps.keys()).join(\", \");\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'RUN_FINISHED' while steps are still active: ${unfinishedSteps}`,\n                  ),\n              );\n            }\n\n            // Check that all messages are finished before run ends\n            if (activeMessages.size > 0) {\n              const unfinishedMessages = Array.from(activeMessages.keys()).join(\", \");\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'RUN_FINISHED' while text messages are still active: ${unfinishedMessages}`,\n                  ),\n              );\n            }\n\n            // Check that all tool calls are finished before run ends\n            if (activeToolCalls.size > 0) {\n              const unfinishedToolCalls = Array.from(activeToolCalls.keys()).join(\", \");\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'RUN_FINISHED' while tool calls are still active: ${unfinishedToolCalls}`,\n                  ),\n              );\n            }\n\n            runFinished = true;\n            return of(event);\n          }\n\n          case EventType.RUN_ERROR: {\n            // RUN_ERROR can happen at any time\n            runError = true; // Set flag to prevent any further events\n            return of(event);\n          }\n\n          case EventType.CUSTOM: {\n            return of(event);\n          }\n\n          // Text message flow\n          case EventType.THINKING_TEXT_MESSAGE_START: {\n            if (!activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_START' event: A thinking step is not in progress. Create one with 'THINKING_START' first.`,\n                  ),\n              );\n            }\n            // Can't start a message if one is already in progress\n            if (activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_START' event: A thinking message is already in progress. Complete it with 'THINKING_TEXT_MESSAGE_END' first.`,\n                  ),\n              );\n            }\n\n            activeThinkingStepMessage = true;\n            return of(event);\n          }\n\n          case EventType.THINKING_TEXT_MESSAGE_CONTENT: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_CONTENT' event: No active thinking message found. Start a message with 'THINKING_TEXT_MESSAGE_START' first.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.THINKING_TEXT_MESSAGE_END: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_END' event: No active thinking message found. A 'THINKING_TEXT_MESSAGE_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Reset message state\n            activeThinkingStepMessage = false;\n            return of(event);\n          }\n\n          case EventType.THINKING_START: {\n            if (activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_START' event: A thinking step is already in progress. End it with 'THINKING_END' first.`,\n                  ),\n              );\n            }\n\n            activeThinkingStep = true;\n            return of(event);\n          }\n\n          case EventType.THINKING_END: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_END' event: No active thinking step found. A 'THINKING_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Reset message state\n            activeThinkingStep = false;\n            return of(event);\n          }\n\n          default: {\n            return of(event);\n          }\n        }\n      }),\n    );\n  };\n","import { BaseEvent, EventSchemas } from \"@ag-ui/core\";\nimport { Subject, ReplaySubject, Observable } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\nimport { parseSSEStream } from \"./sse\";\nimport { parseProtoStream } from \"./proto\";\nimport * as proto from \"@ag-ui/proto\";\nimport { EventType } from \"@ag-ui/core\";\n\n/**\n * Transforms HTTP events into BaseEvents using the appropriate format parser based on content type.\n */\nexport const transformHttpEventStream = (source$: Observable<HttpEvent>): Observable<BaseEvent> => {\n  const eventSubject = new Subject<BaseEvent>();\n\n  // Use ReplaySubject to buffer events until we decide on the parser\n  const bufferSubject = new ReplaySubject<HttpEvent>();\n\n  // Flag to track whether we've set up the parser\n  let parserInitialized = false;\n\n  // Subscribe to source and buffer events while we determine the content type\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      // Forward event to buffer\n      bufferSubject.next(event);\n\n      // If we get headers and haven't initialized a parser yet, check content type\n      if (event.type === HttpEventType.HEADERS && !parserInitialized) {\n        parserInitialized = true;\n        const contentType = event.headers.get(\"content-type\");\n\n        // Choose parser based on content type\n        if (contentType === proto.AGUI_MEDIA_TYPE) {\n          // Use protocol buffer parser\n          parseProtoStream(bufferSubject).subscribe({\n            next: (event) => eventSubject.next(event),\n            error: (err) => eventSubject.error(err),\n            complete: () => eventSubject.complete(),\n          });\n        } else {\n          // Use SSE JSON parser for all other cases\n          parseSSEStream(bufferSubject).subscribe({\n            next: (json) => {\n              try {\n                const parsedEvent = EventSchemas.parse(json);\n                eventSubject.next(parsedEvent as BaseEvent);\n              } catch (err) {\n                eventSubject.error(err);\n              }\n            },\n            error: (err) => {\n              if ((err as DOMException)?.name === \"AbortError\") {\n                eventSubject.next({\n                  type: EventType.RUN_ERROR,\n                  rawEvent: err,\n                });\n                eventSubject.complete();\n                return;\n              }\n              return eventSubject.error(err)\n            },\n            complete: () => eventSubject.complete(),\n          });\n        }\n      } else if (!parserInitialized) {\n        eventSubject.error(new Error(\"No headers event received before data events\"));\n      }\n    },\n    error: (err) => {\n      bufferSubject.error(err);\n      eventSubject.error(err);\n    },\n    complete: () => {\n      bufferSubject.complete();\n    },\n  });\n\n  return eventSubject.asObservable();\n};\n","import { Observable, from, defer, throwError } from \"rxjs\";\nimport { mergeMap, switchMap } from \"rxjs/operators\";\n\nexport enum HttpEventType {\n  HEADERS = \"headers\",\n  DATA = \"data\",\n}\n\nexport interface HttpDataEvent {\n  type: HttpEventType.DATA;\n  data?: Uint8Array;\n}\n\nexport interface HttpHeadersEvent {\n  type: HttpEventType.HEADERS;\n  status: number;\n  headers: Headers;\n}\n\nexport type HttpEvent = HttpDataEvent | HttpHeadersEvent;\n\nexport const runHttpRequest = (url: string, requestInit: RequestInit): Observable<HttpEvent> => {\n  // Defer the fetch so that it's executed when subscribed to\n  return defer(() => from(fetch(url, requestInit))).pipe(\n    switchMap((response) => {\n      if (!response.ok) {\n        const contentType = response.headers.get(\"content-type\") || \"\";\n        // Read the (small) error body once, then error the stream\n        return from(response.text()).pipe(\n          mergeMap((text) => {\n            let payload: unknown = text;\n            if (contentType.includes(\"application/json\")) {\n              try { payload = JSON.parse(text); } catch {/* keep raw text */}\n            }\n            const err: any = new Error(\n              `HTTP ${response.status}: ${typeof payload === \"string\" ? payload : JSON.stringify(payload)}`\n            );\n            err.status = response.status;\n            err.payload = payload;\n            return throwError(() => err);\n          })\n        );\n      }\n      // Emit headers event first\n      const headersEvent: HttpHeadersEvent = {\n        type: HttpEventType.HEADERS,\n        status: response.status,\n        headers: response.headers,\n      };\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        return throwError(() => new Error(\"Failed to getReader() from response\"));\n      }\n\n      return new Observable<HttpEvent>((subscriber) => {\n        // Emit headers event first\n        subscriber.next(headersEvent);\n\n        (async () => {\n          try {\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done) break;\n              // Emit data event instead of raw Uint8Array\n              const dataEvent: HttpDataEvent = {\n                type: HttpEventType.DATA,\n                data: value,\n              };\n              subscriber.next(dataEvent);\n            }\n            subscriber.complete();\n          } catch (error) {\n            subscriber.error(error);\n          }\n        })();\n\n        return () => {\n          reader.cancel().catch((error) => {\n            if ((error as DOMException)?.name === \"AbortError\") {\n              return;\n            }\n\n            throw error;\n          });\n        };\n      });\n    }),\n  );\n};\n","import { Observable, Subject } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\n\n/**\n * Parses a stream of HTTP events into a stream of JSON objects using Server-Sent Events (SSE) format.\n * Strictly follows the SSE standard where:\n * - Events are separated by double newlines ('\\n\\n')\n * - Only 'data:' prefixed lines are processed\n * - Multi-line data events are supported and joined\n * - Non-data fields (event, id, retry) are ignored\n */\nexport const parseSSEStream = (source$: Observable<HttpEvent>): Observable<any> => {\n  const jsonSubject = new Subject<any>();\n  // Create TextDecoder with stream option set to true to handle split UTF-8 characters\n  const decoder = new TextDecoder(\"utf-8\", { fatal: false });\n  let buffer = \"\";\n\n  // Subscribe to the source once and multicast to all subscribers\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      if (event.type === HttpEventType.HEADERS) {\n        return;\n      }\n\n      if (event.type === HttpEventType.DATA && event.data) {\n        // Decode chunk carefully to handle UTF-8\n        const text = decoder.decode(event.data, { stream: true });\n        buffer += text;\n\n        // Process complete events (separated by double newlines)\n        const events = buffer.split(/\\n\\n/);\n        // Keep the last potentially incomplete event in buffer\n        buffer = events.pop() || \"\";\n\n        for (const event of events) {\n          processSSEEvent(event);\n        }\n      }\n    },\n    error: (err) => jsonSubject.error(err),\n    complete: () => {\n      // Use the final call to decoder.decode() to flush any remaining bytes\n      if (buffer) {\n        buffer += decoder.decode();\n        // Process any remaining SSE event data\n        processSSEEvent(buffer);\n      }\n      jsonSubject.complete();\n    },\n  });\n\n  /**\n   * Helper function to process an SSE event.\n   * Extracts and joins data lines, then parses the result as JSON.\n   * Follows the SSE spec by only processing 'data:' prefixed lines.\n   * @param eventText The raw event text to process\n   */\n  function processSSEEvent(eventText: string) {\n    const lines = eventText.split(\"\\n\");\n    const dataLines: string[] = [];\n\n    for (const line of lines) {\n      if (line.startsWith(\"data: \")) {\n        // Extract data content (remove 'data: ' prefix)\n        dataLines.push(line.slice(6));\n      }\n    }\n\n    // Only process if we have data lines\n    if (dataLines.length > 0) {\n      try {\n        // Join multi-line data and parse JSON\n        const jsonStr = dataLines.join(\"\\n\");\n        const json = JSON.parse(jsonStr);\n        jsonSubject.next(json);\n      } catch (err) {\n        jsonSubject.error(err);\n      }\n    }\n  }\n\n  return jsonSubject.asObservable();\n};\n","import { Observable, Subject } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\nimport { BaseEvent } from \"@ag-ui/core\";\nimport * as proto from \"@ag-ui/proto\";\n\n/**\n * Parses a stream of HTTP events into a stream of BaseEvent objects using Protocol Buffer format.\n * Each message is prefixed with a 4-byte length header (uint32 in big-endian format)\n * followed by the protocol buffer encoded message.\n */\nexport const parseProtoStream = (source$: Observable<HttpEvent>): Observable<BaseEvent> => {\n  const eventSubject = new Subject<BaseEvent>();\n  let buffer = new Uint8Array(0);\n\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      if (event.type === HttpEventType.HEADERS) {\n        return;\n      }\n\n      if (event.type === HttpEventType.DATA && event.data) {\n        // Append the new data to our buffer\n        const newBuffer = new Uint8Array(buffer.length + event.data.length);\n        newBuffer.set(buffer, 0);\n        newBuffer.set(event.data, buffer.length);\n        buffer = newBuffer;\n\n        // Process as many complete messages as possible\n        processBuffer();\n      }\n    },\n    error: (err) => eventSubject.error(err),\n    complete: () => {\n      // Try to process any remaining data in the buffer\n      if (buffer.length > 0) {\n        try {\n          processBuffer();\n        } catch (error: unknown) {\n          console.warn(\"Incomplete or invalid protocol buffer data at stream end\");\n        }\n      }\n      eventSubject.complete();\n    },\n  });\n\n  /**\n   * Process as many complete messages as possible from the buffer\n   */\n  function processBuffer() {\n    // Keep processing while we have enough data for at least a header (4 bytes)\n    while (buffer.length >= 4) {\n      // Read message length from the first 4 bytes (big-endian uint32)\n      const view = new DataView(buffer.buffer, buffer.byteOffset, 4);\n      const messageLength = view.getUint32(0, false); // false = big-endian\n\n      // Check if we have the complete message (header + message body)\n      const totalLength = 4 + messageLength;\n      if (buffer.length < totalLength) {\n        // Not enough data yet, wait for more\n        break;\n      }\n\n      try {\n        // Extract the message (skipping the 4-byte header)\n        const message = buffer.slice(4, totalLength);\n\n        // Decode the protocol buffer message using the imported decode function\n        const event = proto.decode(message);\n\n        // Emit the parsed event\n        eventSubject.next(event);\n\n        // Remove the processed message from the buffer\n        buffer = buffer.slice(totalLength);\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        eventSubject.error(new Error(`Failed to decode protocol buffer message: ${errorMessage}`));\n        return;\n      }\n    }\n  }\n\n  return eventSubject.asObservable();\n};\n","import { mergeMap } from \"rxjs/operators\";\nimport { applyPatch } from \"fast-json-patch\";\n\nimport {\n  BaseEvent,\n  EventType,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  CustomEvent,\n  StateSnapshotEvent,\n  StepStartedEvent,\n  Message,\n  StateDeltaEvent,\n  MessagesSnapshotEvent,\n  ToolCall,\n  RunErrorEvent,\n} from \"@ag-ui/core\";\nimport { Observable } from \"rxjs\";\nimport {\n  LegacyTextMessageStart,\n  LegacyTextMessageContent,\n  LegacyTextMessageEnd,\n  LegacyActionExecutionStart,\n  LegacyActionExecutionArgs,\n  LegacyActionExecutionEnd,\n  LegacyRuntimeEventTypes,\n  LegacyRuntimeProtocolEvent,\n  LegacyMetaEvent,\n  LegacyAgentStateMessage,\n  LegacyMessage,\n  LegacyTextMessage,\n  LegacyActionExecutionMessage,\n  LegacyResultMessage,\n  LegacyActionExecutionResult,\n  LegacyRunError\n} from \"./types\";\nimport untruncateJson from \"untruncate-json\";\n\ninterface PredictStateValue {\n  state_key: string;\n  tool: string;\n  tool_argument: string;\n}\n\nexport const convertToLegacyEvents =\n  (threadId: string, runId: string, agentName: string) =>\n  (events$: Observable<BaseEvent>): Observable<LegacyRuntimeProtocolEvent> => {\n    let currentState: any = {};\n    let running = true;\n    let active = true;\n    let nodeName = \"\";\n    let syncedMessages: Message[] | null = null;\n    let predictState: PredictStateValue[] | null = null;\n    let currentToolCalls: ToolCall[] = [];\n    let toolCallNames: Record<string, string> = {};\n\n    const updateCurrentState = (newState: any) => {\n      // the legacy protocol will only support object state\n      if (typeof newState === \"object\" && newState !== null) {\n        if (\"messages\" in newState) {\n          delete newState.messages;\n        }\n        currentState = newState;\n      }\n    };\n\n    return events$.pipe(\n      mergeMap((event) => {\n        switch (event.type) {\n          case EventType.TEXT_MESSAGE_START: {\n            const startEvent = event as TextMessageStartEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageStart,\n                messageId: startEvent.messageId,\n                role: startEvent.role,\n              } as LegacyTextMessageStart,\n            ];\n          }\n          case EventType.TEXT_MESSAGE_CONTENT: {\n            const contentEvent = event as TextMessageContentEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageContent,\n                messageId: contentEvent.messageId,\n                content: contentEvent.delta,\n              } as LegacyTextMessageContent,\n            ];\n          }\n          case EventType.TEXT_MESSAGE_END: {\n            const endEvent = event as TextMessageEndEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageEnd,\n                messageId: endEvent.messageId,\n              } as LegacyTextMessageEnd,\n            ];\n          }\n          case EventType.TOOL_CALL_START: {\n            const startEvent = event as ToolCallStartEvent;\n\n            currentToolCalls.push({\n              id: startEvent.toolCallId,\n              type: \"function\",\n              function: {\n                name: startEvent.toolCallName,\n                arguments: \"\",\n              },\n            });\n\n            active = true;\n            toolCallNames[startEvent.toolCallId] = startEvent.toolCallName;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionStart,\n                actionExecutionId: startEvent.toolCallId,\n                actionName: startEvent.toolCallName,\n                parentMessageId: startEvent.parentMessageId,\n              } as LegacyActionExecutionStart,\n            ];\n          }\n          case EventType.TOOL_CALL_ARGS: {\n            const argsEvent = event as ToolCallArgsEvent;\n\n            // Find the tool call by ID instead of using the last one\n            const currentToolCall = currentToolCalls.find((tc) => tc.id === argsEvent.toolCallId);\n            if (!currentToolCall) {\n              console.warn(`TOOL_CALL_ARGS: No tool call found with ID '${argsEvent.toolCallId}'`);\n              return [];\n            }\n\n            currentToolCall.function.arguments += argsEvent.delta;\n            let didUpdateState = false;\n\n            if (predictState) {\n              let currentPredictState = predictState.find(\n                (s) => s.tool == currentToolCall.function.name,\n              );\n\n              if (currentPredictState) {\n                try {\n                  const currentArgs = JSON.parse(\n                    untruncateJson(currentToolCall.function.arguments),\n                  );\n                  if (\n                    currentPredictState.tool_argument &&\n                    currentPredictState.tool_argument in currentArgs\n                  ) {\n                    updateCurrentState({\n                      ...currentState,\n                      [currentPredictState.state_key]:\n                        currentArgs[currentPredictState.tool_argument],\n                    });\n                    didUpdateState = true;\n                  } else if (!currentPredictState.tool_argument) {\n                    updateCurrentState({\n                      ...currentState,\n                      [currentPredictState.state_key]: currentArgs,\n                    });\n                    didUpdateState = true;\n                  }\n                } catch (e) {}\n              }\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionArgs,\n                actionExecutionId: argsEvent.toolCallId,\n                args: argsEvent.delta,\n              } as LegacyActionExecutionArgs,\n              ...(didUpdateState\n                ? [\n                    {\n                      type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                      threadId,\n                      agentName,\n                      nodeName,\n                      runId,\n                      running,\n                      role: \"assistant\",\n                      state: JSON.stringify(currentState),\n                      active,\n                    },\n                  ]\n                : []),\n            ];\n          }\n          case EventType.TOOL_CALL_END: {\n            const endEvent = event as ToolCallEndEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionEnd,\n                actionExecutionId: endEvent.toolCallId,\n              } as LegacyActionExecutionEnd,\n            ];\n          }\n          case EventType.TOOL_CALL_RESULT: {\n            const resultEvent = event as ToolCallResultEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionResult,\n                actionExecutionId: resultEvent.toolCallId,\n                result: resultEvent.content,\n                actionName: toolCallNames[resultEvent.toolCallId] || \"unknown\",\n              } as LegacyActionExecutionResult,\n            ];\n          }\n          case EventType.RAW: {\n            // The legacy protocol doesn't support raw events\n            return [];\n          }\n          case EventType.CUSTOM: {\n            const customEvent = event as CustomEvent;\n            switch (customEvent.name) {\n              case \"Exit\":\n                running = false;\n                break;\n              case \"PredictState\":\n                predictState = customEvent.value as PredictStateValue[];\n                break;\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.MetaEvent,\n                name: customEvent.name,\n                value: customEvent.value,\n              } as LegacyMetaEvent,\n            ];\n          }\n          case EventType.STATE_SNAPSHOT: {\n            const stateEvent = event as StateSnapshotEvent;\n            updateCurrentState(stateEvent.snapshot);\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.STATE_DELTA: {\n            const deltaEvent = event as StateDeltaEvent;\n            const result = applyPatch(currentState, deltaEvent.delta, true, false);\n            if (!result) {\n              return [];\n            }\n            updateCurrentState(result.newDocument);\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.MESSAGES_SNAPSHOT: {\n            const messagesSnapshot = event as MessagesSnapshotEvent;\n            syncedMessages = messagesSnapshot.messages;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify({\n                  ...currentState,\n                  ...(syncedMessages ? { messages: syncedMessages } : {}),\n                }),\n                active: true,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.RUN_STARTED: {\n            // There is nothing to do in the legacy protocol\n            return [];\n          }\n          case EventType.RUN_FINISHED: {\n            if (syncedMessages) {\n              currentState.messages = syncedMessages;\n            }\n\n            // Only do an update if state is not empty\n            if (Object.keys(currentState).length === 0) {\n              return [];\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify({\n                  ...currentState,\n                  ...(syncedMessages\n                    ? {\n                        messages: convertMessagesToLegacyFormat(syncedMessages),\n                      }\n                    : {}),\n                }),\n                active: false,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.RUN_ERROR: {\n            const errorEvent = event as RunErrorEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.RunError,\n                message: errorEvent.message,\n                code: errorEvent.code,\n              } as LegacyRunError,\n            ];\n          }\n          case EventType.STEP_STARTED: {\n            const stepStarted = event as StepStartedEvent;\n            nodeName = stepStarted.stepName;\n\n            currentToolCalls = [];\n            predictState = null;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active: true,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.STEP_FINISHED: {\n            currentToolCalls = [];\n            predictState = null;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active: false,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          default: {\n            return [];\n          }\n        }\n      }),\n    );\n  };\n\nexport function convertMessagesToLegacyFormat(messages: Message[]): LegacyMessage[] {\n  const result: LegacyMessage[] = [];\n\n  for (const message of messages) {\n    if (message.role === \"assistant\" || message.role === \"user\" || message.role === \"system\") {\n      if (message.content) {\n        const textMessage: LegacyTextMessage = {\n          id: message.id,\n          role: message.role,\n          content: message.content,\n        };\n        result.push(textMessage);\n      }\n      if (message.role === \"assistant\" && message.toolCalls && message.toolCalls.length > 0) {\n        for (const toolCall of message.toolCalls) {\n          const actionExecutionMessage: LegacyActionExecutionMessage = {\n            id: toolCall.id,\n            name: toolCall.function.name,\n            arguments: JSON.parse(toolCall.function.arguments),\n            parentMessageId: message.id,\n          };\n          result.push(actionExecutionMessage);\n        }\n      }\n    } else if (message.role === \"tool\") {\n      let actionName = \"unknown\";\n      for (const m of messages) {\n        if (m.role === \"assistant\" && m.toolCalls?.length) {\n          for (const toolCall of m.toolCalls) {\n            if (toolCall.id === message.toolCallId) {\n              actionName = toolCall.function.name;\n              break;\n            }\n          }\n        }\n      }\n      const toolMessage: LegacyResultMessage = {\n        id: message.id,\n        result: message.content,\n        actionExecutionId: message.toolCallId,\n        actionName,\n      };\n      result.push(toolMessage);\n    }\n  }\n\n  return result;\n}\n","import { z } from \"zod\";\n\n// Protocol Events\nexport const LegacyRuntimeEventTypes = z.enum([\n  \"TextMessageStart\",\n  \"TextMessageContent\",\n  \"TextMessageEnd\",\n  \"ActionExecutionStart\",\n  \"ActionExecutionArgs\",\n  \"ActionExecutionEnd\",\n  \"ActionExecutionResult\",\n  \"AgentStateMessage\",\n  \"MetaEvent\",\n  \"RunStarted\",\n  \"RunFinished\",\n  \"RunError\",\n  \"NodeStarted\",\n  \"NodeFinished\",\n]);\n\nexport const LegacyRuntimeMetaEventName = z.enum([\n  \"LangGraphInterruptEvent\",\n  \"PredictState\",\n  \"Exit\",\n]);\n\nexport const LegacyTextMessageStart = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageStart),\n  messageId: z.string(),\n  parentMessageId: z.string().optional(),\n  role: z.string().optional(),\n});\n\nexport const LegacyTextMessageContent = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageContent),\n  messageId: z.string(),\n  content: z.string(),\n});\n\nexport const LegacyTextMessageEnd = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageEnd),\n  messageId: z.string(),\n});\n\nexport const LegacyActionExecutionStart = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionStart),\n  actionExecutionId: z.string(),\n  actionName: z.string(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyActionExecutionArgs = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionArgs),\n  actionExecutionId: z.string(),\n  args: z.string(),\n});\n\nexport const LegacyActionExecutionEnd = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionEnd),\n  actionExecutionId: z.string(),\n});\n\nexport const LegacyActionExecutionResult = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionResult),\n  actionName: z.string(),\n  actionExecutionId: z.string(),\n  result: z.string(),\n});\n\nexport const LegacyAgentStateMessage = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.AgentStateMessage),\n  threadId: z.string(),\n  agentName: z.string(),\n  nodeName: z.string(),\n  runId: z.string(),\n  active: z.boolean(),\n  role: z.string(),\n  state: z.string(),\n  running: z.boolean(),\n});\n\nexport const LegacyMetaEvent = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.MetaEvent),\n  name: LegacyRuntimeMetaEventName,\n  value: z.any(),\n});\n\n\nexport const LegacyRunError = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.RunError),\n  message: z.string(),\n  code: z.string().optional(),\n});\n\nexport const LegacyRuntimeProtocolEvent = z.discriminatedUnion(\"type\", [\n  LegacyTextMessageStart,\n  LegacyTextMessageContent,\n  LegacyTextMessageEnd,\n  LegacyActionExecutionStart,\n  LegacyActionExecutionArgs,\n  LegacyActionExecutionEnd,\n  LegacyActionExecutionResult,\n  LegacyAgentStateMessage,\n  LegacyMetaEvent,\n  LegacyRunError,\n]);\n\n// Protocol Event type exports\nexport type RuntimeEventTypes = z.infer<typeof LegacyRuntimeEventTypes>;\nexport type RuntimeMetaEventName = z.infer<typeof LegacyRuntimeMetaEventName>;\nexport type LegacyTextMessageStart = z.infer<typeof LegacyTextMessageStart>;\nexport type LegacyTextMessageContent = z.infer<typeof LegacyTextMessageContent>;\nexport type LegacyTextMessageEnd = z.infer<typeof LegacyTextMessageEnd>;\nexport type LegacyActionExecutionStart = z.infer<typeof LegacyActionExecutionStart>;\nexport type LegacyActionExecutionArgs = z.infer<typeof LegacyActionExecutionArgs>;\nexport type LegacyActionExecutionEnd = z.infer<typeof LegacyActionExecutionEnd>;\nexport type LegacyActionExecutionResult = z.infer<typeof LegacyActionExecutionResult>;\nexport type LegacyAgentStateMessage = z.infer<typeof LegacyAgentStateMessage>;\nexport type LegacyMetaEvent = z.infer<typeof LegacyMetaEvent>;\nexport type LegacyRuntimeProtocolEvent = z.infer<typeof LegacyRuntimeProtocolEvent>;\nexport type LegacyRunError = z.infer<typeof LegacyRunError>;\n\n// Message schemas (with kind discriminator)\nexport const LegacyTextMessageSchema = z.object({\n  id: z.string(),\n  role: z.string(),\n  content: z.string(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyActionExecutionMessageSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  arguments: z.any(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyResultMessageSchema = z.object({\n  id: z.string(),\n  result: z.any(),\n  actionExecutionId: z.string(),\n  actionName: z.string(),\n});\n\n// Message type exports\nexport type LegacyTextMessage = z.infer<typeof LegacyTextMessageSchema>;\nexport type LegacyActionExecutionMessage = z.infer<typeof LegacyActionExecutionMessageSchema>;\nexport type LegacyResultMessage = z.infer<typeof LegacyResultMessageSchema>;\nexport type LegacyMessage = LegacyTextMessage | LegacyActionExecutionMessage | LegacyResultMessage;\n","import { defaultApplyEvents } from \"@/apply/default\";\nimport { Message, State, RunAgentInput, BaseEvent, ToolCall, AssistantMessage } from \"@ag-ui/core\";\n\nimport { AgentConfig, RunAgentParameters } from \"./types\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { structuredClone_ } from \"@/utils\";\nimport { catchError, map, tap } from \"rxjs/operators\";\nimport { finalize } from \"rxjs/operators\";\nimport { pipe, Observable, from, of } from \"rxjs\";\nimport { verifyEvents } from \"@/verify\";\nimport { convertToLegacyEvents } from \"@/legacy/convert\";\nimport { LegacyRuntimeProtocolEvent } from \"@/legacy/types\";\nimport { lastValueFrom } from \"rxjs\";\nimport { transformChunks } from \"@/chunks\";\nimport { AgentStateMutation, AgentSubscriber, runSubscribersWithMutation } from \"./subscriber\";\n\nexport interface RunAgentResult {\n  result: any;\n  newMessages: Message[];\n}\n\nexport abstract class AbstractAgent {\n  public agentId?: string;\n  public description: string;\n  public threadId: string;\n  public messages: Message[];\n  public state: State;\n  public debug: boolean = false;\n  public subscribers: AgentSubscriber[] = [];\n\n  constructor({\n    agentId,\n    description,\n    threadId,\n    initialMessages,\n    initialState,\n    debug,\n  }: AgentConfig = {}) {\n    this.agentId = agentId;\n    this.description = description ?? \"\";\n    this.threadId = threadId ?? uuidv4();\n    this.messages = structuredClone_(initialMessages ?? []);\n    this.state = structuredClone_(initialState ?? {});\n    this.debug = debug ?? false;\n  }\n\n  public subscribe(subscriber: AgentSubscriber) {\n    this.subscribers.push(subscriber);\n    return {\n      unsubscribe: () => {\n        this.subscribers = this.subscribers.filter((s) => s !== subscriber);\n      },\n    };\n  }\n\n  protected abstract run(input: RunAgentInput): Observable<BaseEvent>;\n\n  public async runAgent(\n    parameters?: RunAgentParameters,\n    subscriber?: AgentSubscriber,\n  ): Promise<RunAgentResult> {\n    this.agentId = this.agentId ?? uuidv4();\n    const input = this.prepareRunAgentInput(parameters);\n    let result: any = undefined;\n    const currentMessageIds = new Set(this.messages.map((message) => message.id));\n\n    const subscribers: AgentSubscriber[] = [\n      {\n        onRunFinishedEvent: (params) => {\n          result = params.result;\n        },\n      },\n      ...this.subscribers,\n      subscriber ?? {},\n    ];\n\n    await this.onInitialize(input, subscribers);\n\n    const pipeline = pipe(\n      () => this.run(input),\n      transformChunks(this.debug),\n      verifyEvents(this.debug),\n      (source$) => this.apply(input, source$, subscribers),\n      (source$) => this.processApplyEvents(input, source$, subscribers),\n      catchError((error) => {\n        return this.onError(input, error, subscribers);\n      }),\n      finalize(() => {\n        void this.onFinalize(input, subscribers);\n      }),\n    );\n\n    return lastValueFrom(pipeline(of(null))).then(() => {\n      const newMessages = structuredClone_(this.messages).filter(\n        (message: Message) => !currentMessageIds.has(message.id),\n      );\n      return { result, newMessages };\n    });\n  }\n\n  public abortRun() {}\n\n  protected apply(\n    input: RunAgentInput,\n    events$: Observable<BaseEvent>,\n    subscribers: AgentSubscriber[],\n  ): Observable<AgentStateMutation> {\n    return defaultApplyEvents(input, events$, this, subscribers);\n  }\n\n  protected processApplyEvents(\n    input: RunAgentInput,\n    events$: Observable<AgentStateMutation>,\n    subscribers: AgentSubscriber[],\n  ): Observable<AgentStateMutation> {\n    return events$.pipe(\n      tap((event) => {\n        if (event.messages) {\n          this.messages = event.messages;\n          subscribers.forEach((subscriber) => {\n            subscriber.onMessagesChanged?.({\n              messages: this.messages,\n              state: this.state,\n              agent: this,\n              input,\n            });\n          });\n        }\n        if (event.state) {\n          this.state = event.state;\n          subscribers.forEach((subscriber) => {\n            subscriber.onStateChanged?.({\n              state: this.state,\n              messages: this.messages,\n              agent: this,\n              input,\n            });\n          });\n        }\n      }),\n    );\n  }\n\n  protected prepareRunAgentInput(parameters?: RunAgentParameters): RunAgentInput {\n    return {\n      threadId: this.threadId,\n      runId: parameters?.runId || uuidv4(),\n      tools: structuredClone_(parameters?.tools ?? []),\n      context: structuredClone_(parameters?.context ?? []),\n      forwardedProps: structuredClone_(parameters?.forwardedProps ?? {}),\n      state: structuredClone_(this.state),\n      messages: structuredClone_(this.messages),\n    };\n  }\n\n  protected async onInitialize(input: RunAgentInput, subscribers: AgentSubscriber[]) {\n    const onRunInitializedMutation = await runSubscribersWithMutation(\n      subscribers,\n      this.messages,\n      this.state,\n      (subscriber, messages, state) =>\n        subscriber.onRunInitialized?.({ messages, state, agent: this, input }),\n    );\n    if (\n      onRunInitializedMutation.messages !== undefined ||\n      onRunInitializedMutation.state !== undefined\n    ) {\n      if (onRunInitializedMutation.messages) {\n        this.messages = onRunInitializedMutation.messages;\n        input.messages = onRunInitializedMutation.messages;\n        subscribers.forEach((subscriber) => {\n          subscriber.onMessagesChanged?.({\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n            input,\n          });\n        });\n      }\n      if (onRunInitializedMutation.state) {\n        this.state = onRunInitializedMutation.state;\n        input.state = onRunInitializedMutation.state;\n        subscribers.forEach((subscriber) => {\n          subscriber.onStateChanged?.({\n            state: this.state,\n            messages: this.messages,\n            agent: this,\n            input,\n          });\n        });\n      }\n    }\n  }\n\n  protected onError(input: RunAgentInput, error: Error, subscribers: AgentSubscriber[]) {\n    return from(\n      runSubscribersWithMutation(\n        subscribers,\n        this.messages,\n        this.state,\n        (subscriber, messages, state) =>\n          subscriber.onRunFailed?.({ error, messages, state, agent: this, input }),\n      ),\n    ).pipe(\n      map((onRunFailedMutation) => {\n        const mutation = onRunFailedMutation as AgentStateMutation;\n        if (mutation.messages !== undefined || mutation.state !== undefined) {\n          if (mutation.messages !== undefined) {\n            this.messages = mutation.messages;\n            subscribers.forEach((subscriber) => {\n              subscriber.onMessagesChanged?.({\n                messages: this.messages,\n                state: this.state,\n                agent: this,\n                input,\n              });\n            });\n          }\n          if (mutation.state !== undefined) {\n            this.state = mutation.state;\n            subscribers.forEach((subscriber) => {\n              subscriber.onStateChanged?.({\n                state: this.state,\n                messages: this.messages,\n                agent: this,\n                input,\n              });\n            });\n          }\n        }\n\n        if (mutation.stopPropagation !== true) {\n          console.error(\"Agent execution failed:\", error);\n          throw error;\n        }\n\n        // Return an empty mutation instead of null to prevent EmptyError\n        return {} as AgentStateMutation;\n      }),\n    );\n  }\n\n  protected async onFinalize(input: RunAgentInput, subscribers: AgentSubscriber[]) {\n    const onRunFinalizedMutation = await runSubscribersWithMutation(\n      subscribers,\n      this.messages,\n      this.state,\n      (subscriber, messages, state) =>\n        subscriber.onRunFinalized?.({ messages, state, agent: this, input }),\n    );\n\n    if (\n      onRunFinalizedMutation.messages !== undefined ||\n      onRunFinalizedMutation.state !== undefined\n    ) {\n      if (onRunFinalizedMutation.messages !== undefined) {\n        this.messages = onRunFinalizedMutation.messages;\n        subscribers.forEach((subscriber) => {\n          subscriber.onMessagesChanged?.({\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n            input,\n          });\n        });\n      }\n      if (onRunFinalizedMutation.state !== undefined) {\n        this.state = onRunFinalizedMutation.state;\n        subscribers.forEach((subscriber) => {\n          subscriber.onStateChanged?.({\n            state: this.state,\n            messages: this.messages,\n            agent: this,\n            input,\n          });\n        });\n      }\n    }\n  }\n\n  public clone() {\n    const cloned = Object.create(Object.getPrototypeOf(this));\n\n    for (const key of Object.getOwnPropertyNames(this)) {\n      const value = (this as any)[key];\n      if (typeof value !== \"function\") {\n        cloned[key] = structuredClone_(value);\n      }\n    }\n\n    return cloned;\n  }\n\n  public addMessage(message: Message) {\n    // Add message to the messages array\n    this.messages.push(message);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onNewMessage sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onNewMessage?.({\n          message,\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n\n      // Fire onNewToolCall if the message is from assistant and contains tool calls\n      if (message.role === \"assistant\" && message.toolCalls) {\n        for (const toolCall of message.toolCalls) {\n          for (const subscriber of this.subscribers) {\n            await subscriber.onNewToolCall?.({\n              toolCall,\n              messages: this.messages,\n              state: this.state,\n              agent: this,\n            });\n          }\n        }\n      }\n\n      // Fire onMessagesChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public addMessages(messages: Message[]) {\n    // Add all messages to the messages array\n    this.messages.push(...messages);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onNewMessage and onNewToolCall for each message sequentially\n      for (const message of messages) {\n        // Fire onNewMessage sequentially\n        for (const subscriber of this.subscribers) {\n          await subscriber.onNewMessage?.({\n            message,\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n          });\n        }\n\n        // Fire onNewToolCall if the message is from assistant and contains tool calls\n        if (message.role === \"assistant\" && message.toolCalls) {\n          for (const toolCall of message.toolCalls) {\n            for (const subscriber of this.subscribers) {\n              await subscriber.onNewToolCall?.({\n                toolCall,\n                messages: this.messages,\n                state: this.state,\n                agent: this,\n              });\n            }\n          }\n        }\n      }\n\n      // Fire onMessagesChanged once at the end sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public setMessages(messages: Message[]) {\n    // Replace the entire messages array\n    this.messages = structuredClone_(messages);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onMessagesChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public setState(state: State) {\n    // Replace the entire state\n    this.state = structuredClone_(state);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onStateChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onStateChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public legacy_to_be_removed_runAgentBridged(\n    config?: RunAgentParameters,\n  ): Observable<LegacyRuntimeProtocolEvent> {\n    this.agentId = this.agentId ?? uuidv4();\n    const input = this.prepareRunAgentInput(config);\n\n    return this.run(input).pipe(\n      transformChunks(this.debug),\n      verifyEvents(this.debug),\n      convertToLegacyEvents(this.threadId, input.runId, this.agentId),\n      (events$: Observable<LegacyRuntimeProtocolEvent>) => {\n        return events$.pipe(\n          map((event) => {\n            if (this.debug) {\n              console.debug(\"[LEGACY]:\", JSON.stringify(event));\n            }\n            return event;\n          }),\n        );\n      },\n    );\n  }\n}\n","import { mergeMap, Observable, finalize } from \"rxjs\";\nimport {\n  BaseEvent,\n  TextMessageChunkEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  TextMessageStartEvent,\n  ToolCallArgsEvent,\n  ToolCallChunkEvent,\n  ToolCallEndEvent,\n  ToolCallStartEvent,\n} from \"@ag-ui/core\";\nimport { EventType } from \"@ag-ui/core\";\n\ninterface TextMessageFields {\n  messageId: string;\n}\n\ninterface ToolCallFields {\n  toolCallId: string;\n  toolCallName: string;\n  parentMessageId?: string;\n}\n\nexport const transformChunks =\n  (debug: boolean) =>\n  (events$: Observable<BaseEvent>): Observable<BaseEvent> => {\n    let textMessageFields: TextMessageFields | undefined;\n    let toolCallFields: ToolCallFields | undefined;\n    let mode: \"text\" | \"tool\" | undefined;\n\n    const closeTextMessage = () => {\n      if (!textMessageFields || mode !== \"text\") {\n        throw new Error(\"No text message to close\");\n      }\n      const event = {\n        type: EventType.TEXT_MESSAGE_END,\n        messageId: textMessageFields.messageId,\n      } as TextMessageEndEvent;\n      mode = undefined;\n      textMessageFields = undefined;\n\n      if (debug) {\n        console.debug(\"[TRANSFORM]: TEXT_MESSAGE_END\", JSON.stringify(event));\n      }\n\n      return event;\n    };\n\n    const closeToolCall = () => {\n      if (!toolCallFields || mode !== \"tool\") {\n        throw new Error(\"No tool call to close\");\n      }\n      const event = {\n        type: EventType.TOOL_CALL_END,\n        toolCallId: toolCallFields.toolCallId,\n      } as ToolCallEndEvent;\n      mode = undefined;\n      toolCallFields = undefined;\n\n      if (debug) {\n        console.debug(\"[TRANSFORM]: TOOL_CALL_END\", JSON.stringify(event));\n      }\n\n      return event;\n    };\n\n    const closePendingEvent = () => {\n      if (mode === \"text\") {\n        return [closeTextMessage()];\n      }\n      if (mode === \"tool\") {\n        return [closeToolCall()];\n      }\n      return [];\n    };\n\n    return events$.pipe(\n      mergeMap((event) => {\n        switch (event.type) {\n          case EventType.TEXT_MESSAGE_START:\n          case EventType.TEXT_MESSAGE_CONTENT:\n          case EventType.TEXT_MESSAGE_END:\n          case EventType.TOOL_CALL_START:\n          case EventType.TOOL_CALL_ARGS:\n          case EventType.TOOL_CALL_END:\n          case EventType.TOOL_CALL_RESULT:\n          case EventType.STATE_SNAPSHOT:\n          case EventType.STATE_DELTA:\n          case EventType.MESSAGES_SNAPSHOT:\n          case EventType.CUSTOM:\n          case EventType.RUN_STARTED:\n          case EventType.RUN_FINISHED:\n          case EventType.RUN_ERROR:\n          case EventType.STEP_STARTED:\n          case EventType.STEP_FINISHED:\n          case EventType.THINKING_START:\n          case EventType.THINKING_END:\n          case EventType.THINKING_TEXT_MESSAGE_START:\n          case EventType.THINKING_TEXT_MESSAGE_CONTENT:\n          case EventType.THINKING_TEXT_MESSAGE_END:\n            return [...closePendingEvent(), event];\n          case EventType.RAW:\n            return [event];\n          case EventType.TEXT_MESSAGE_CHUNK:\n            const messageChunkEvent = event as TextMessageChunkEvent;\n            const textMessageResult = [];\n            if (\n              // we are not in a text message\n              mode !== \"text\" ||\n              // or the message id is different\n              (messageChunkEvent.messageId !== undefined &&\n                messageChunkEvent.messageId !== textMessageFields?.messageId)\n            ) {\n              // close the current message if any\n              textMessageResult.push(...closePendingEvent());\n            }\n\n            // we are not in a text message, start a new one\n            if (mode !== \"text\") {\n              if (messageChunkEvent.messageId === undefined) {\n                throw new Error(\"First TEXT_MESSAGE_CHUNK must have a messageId\");\n              }\n\n              textMessageFields = {\n                messageId: messageChunkEvent.messageId,\n              };\n              mode = \"text\";\n\n              const textMessageStartEvent = {\n                type: EventType.TEXT_MESSAGE_START,\n                messageId: messageChunkEvent.messageId,\n                role: messageChunkEvent.role || \"assistant\",\n              } as TextMessageStartEvent;\n\n              textMessageResult.push(textMessageStartEvent);\n\n              if (debug) {\n                console.debug(\n                  \"[TRANSFORM]: TEXT_MESSAGE_START\",\n                  JSON.stringify(textMessageStartEvent),\n                );\n              }\n            }\n\n            if (messageChunkEvent.delta !== undefined) {\n              const textMessageContentEvent = {\n                type: EventType.TEXT_MESSAGE_CONTENT,\n                messageId: textMessageFields!.messageId,\n                delta: messageChunkEvent.delta,\n              } as TextMessageContentEvent;\n\n              textMessageResult.push(textMessageContentEvent);\n\n              if (debug) {\n                console.debug(\n                  \"[TRANSFORM]: TEXT_MESSAGE_CONTENT\",\n                  JSON.stringify(textMessageContentEvent),\n                );\n              }\n            }\n\n            return textMessageResult;\n          case EventType.TOOL_CALL_CHUNK:\n            const toolCallChunkEvent = event as ToolCallChunkEvent;\n            const toolMessageResult = [];\n            if (\n              // we are not in a text message\n              mode !== \"tool\" ||\n              // or the tool call id is different\n              (toolCallChunkEvent.toolCallId !== undefined &&\n                toolCallChunkEvent.toolCallId !== toolCallFields?.toolCallId)\n            ) {\n              // close the current message if any\n              toolMessageResult.push(...closePendingEvent());\n            }\n\n            if (mode !== \"tool\") {\n              if (toolCallChunkEvent.toolCallId === undefined) {\n                throw new Error(\"First TOOL_CALL_CHUNK must have a toolCallId\");\n              }\n              if (toolCallChunkEvent.toolCallName === undefined) {\n                throw new Error(\"First TOOL_CALL_CHUNK must have a toolCallName\");\n              }\n              toolCallFields = {\n                toolCallId: toolCallChunkEvent.toolCallId,\n                toolCallName: toolCallChunkEvent.toolCallName,\n                parentMessageId: toolCallChunkEvent.parentMessageId,\n              };\n              mode = \"tool\";\n\n              const toolCallStartEvent = {\n                type: EventType.TOOL_CALL_START,\n                toolCallId: toolCallChunkEvent.toolCallId,\n                toolCallName: toolCallChunkEvent.toolCallName,\n                parentMessageId: toolCallChunkEvent.parentMessageId,\n              } as ToolCallStartEvent;\n\n              toolMessageResult.push(toolCallStartEvent);\n\n              if (debug) {\n                console.debug(\"[TRANSFORM]: TOOL_CALL_START\", JSON.stringify(toolCallStartEvent));\n              }\n            }\n\n            if (toolCallChunkEvent.delta !== undefined) {\n              const toolCallArgsEvent = {\n                type: EventType.TOOL_CALL_ARGS,\n                toolCallId: toolCallFields!.toolCallId,\n                delta: toolCallChunkEvent.delta,\n              } as ToolCallArgsEvent;\n\n              toolMessageResult.push(toolCallArgsEvent);\n\n              if (debug) {\n                console.debug(\"[TRANSFORM]: TOOL_CALL_ARGS\", JSON.stringify(toolCallArgsEvent));\n              }\n            }\n\n            return toolMessageResult;\n        }\n        const _exhaustiveCheck: never = event.type;\n      }),\n      finalize(() => {\n        // This ensures that we close any pending events when the source observable completes\n        return closePendingEvent();\n      }),\n    );\n  };\n","import { AbstractAgent, RunAgentResult } from \"./agent\";\nimport { runHttpRequest } from \"@/run/http-request\";\nimport { HttpAgentConfig, RunAgentParameters } from \"./types\";\nimport { RunAgentInput, BaseEvent } from \"@ag-ui/core\";\nimport { structuredClone_ } from \"@/utils\";\nimport { transformHttpEventStream } from \"@/transform/http\";\nimport { Observable } from \"rxjs\";\nimport { AgentSubscriber } from \"./subscriber\";\n\ninterface RunHttpAgentConfig extends RunAgentParameters {\n  abortController?: AbortController;\n}\n\nexport class HttpAgent extends AbstractAgent {\n  public url: string;\n  public headers: Record<string, string>;\n  public abortController: AbortController = new AbortController();\n\n  /**\n   * Returns the fetch config for the http request.\n   * Override this to customize the request.\n   *\n   * @returns The fetch config for the http request.\n   */\n  protected requestInit(input: RunAgentInput): RequestInit {\n    return {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\",\n        Accept: \"text/event-stream\",\n      },\n      body: JSON.stringify(input),\n      signal: this.abortController.signal,\n    };\n  }\n\n  public runAgent(\n    parameters?: RunHttpAgentConfig,\n    subscriber?: AgentSubscriber,\n  ): Promise<RunAgentResult> {\n    this.abortController = parameters?.abortController ?? new AbortController();\n    return super.runAgent(parameters, subscriber);\n  }\n\n  abortRun() {\n    this.abortController.abort();\n    super.abortRun();\n  }\n\n  constructor(config: HttpAgentConfig) {\n    super(config);\n    this.url = config.url;\n    this.headers = structuredClone_(config.headers ?? {});\n  }\n\n  run(input: RunAgentInput): Observable<BaseEvent> {\n    const httpEvents = runHttpRequest(this.url, this.requestInit(input));\n    return transformHttpEventStream(httpEvents);\n  }\n}\n","export * from \"./apply\";\nexport * from \"./verify\";\nexport * from \"./transform\";\nexport * from \"./run\";\nexport * from \"./legacy\";\nexport * from \"./agent\";\nexport * from \"@ag-ui/core\";\n"],"names":["EventType","mergeAll","defaultIfEmpty","concatMap","of","EMPTY","structuredClone_","obj","err","__spreadValues","applyPatch","runSubscribersWithMutation","subscribers","initialMessages","initialState","executor","messages","state","stopPropagation","subscriber","mutation","structuredClone_","error","__spreadValues","untruncateJson","defaultApplyEvents","input","events$","agent","subscribers","messages","structuredClone_","state","currentMutation","applyMutation","mutation","emitUpdates","result","of","EMPTY","concatMap","event","_a","runSubscribersWithMutation","subscriber","EventType","messageId","role","newMessage","delta","targetMessage","m","_b","toolCallId","toolCallName","parentMessageId","tc","targetToolCall","toolCallBuffer","partialToolCallArgs","error","toolCallArgsString","toolCallArgs","content","toolMessage","snapshot","applyPatch","errorMessage","newMessages","_exhaustiveCheck","mergeAll","defaultIfEmpty","stream","EventType","AGUIError","throwError","of","mergeMap","verifyEvents","debug","source$","activeMessages","activeToolCalls","runFinished","runError","firstEventReceived","activeSteps","activeThinkingStep","activeThinkingStepMessage","runStarted","resetRunState","event","eventType","messageId","toolCallId","stepName","unfinishedSteps","unfinishedMessages","unfinishedToolCalls","EventSchemas","Subject","ReplaySubject","Observable","from","defer","throwError","mergeMap","switchMap","runHttpRequest","url","requestInit","defer","from","switchMap","response","_a","contentType","mergeMap","text","payload","e","err","throwError","headersEvent","reader","Observable","subscriber","done","value","dataEvent","error","Subject","parseSSEStream","source$","jsonSubject","Subject","decoder","buffer","event","text","events","processSSEEvent","err","eventText","lines","dataLines","line","jsonStr","json","Subject","proto","parseProtoStream","source$","eventSubject","Subject","buffer","event","newBuffer","processBuffer","err","error","totalLength","message","errorMessage","proto","EventType","transformHttpEventStream","source$","eventSubject","Subject","bufferSubject","ReplaySubject","parserInitialized","event","parseProtoStream","err","parseSSEStream","json","parsedEvent","EventSchemas","mergeMap","applyPatch","EventType","z","LegacyRuntimeEventTypes","LegacyRuntimeMetaEventName","LegacyTextMessageStart","LegacyTextMessageContent","LegacyTextMessageEnd","LegacyActionExecutionStart","LegacyActionExecutionArgs","LegacyActionExecutionEnd","LegacyActionExecutionResult","LegacyAgentStateMessage","LegacyMetaEvent","LegacyRunError","LegacyRuntimeProtocolEvent","LegacyTextMessageSchema","LegacyActionExecutionMessageSchema","LegacyResultMessageSchema","untruncateJson","convertToLegacyEvents","threadId","runId","agentName","events$","currentState","running","active","nodeName","syncedMessages","predictState","currentToolCalls","toolCallNames","updateCurrentState","newState","mergeMap","event","EventType","startEvent","LegacyRuntimeEventTypes","contentEvent","endEvent","argsEvent","currentToolCall","tc","didUpdateState","currentPredictState","s","currentArgs","untruncateJson","__spreadProps","__spreadValues","e","resultEvent","customEvent","result","applyPatch","convertMessagesToLegacyFormat","errorEvent","messages","_a","message","textMessage","toolCall","actionExecutionMessage","actionName","m","toolMessage","uuidv4","catchError","map","tap","finalize","pipe","from","of","lastValueFrom","mergeMap","finalize","EventType","transformChunks","debug","events$","textMessageFields","toolCallFields","mode","closeTextMessage","event","closeToolCall","closePendingEvent","messageChunkEvent","textMessageResult","textMessageStartEvent","textMessageContentEvent","toolCallChunkEvent","toolMessageResult","toolCallStartEvent","toolCallArgsEvent","_exhaustiveCheck","AbstractAgent","agentId","description","threadId","initialMessages","initialState","debug","uuidv4","structuredClone_","subscriber","s","parameters","_a","input","result","currentMessageIds","message","subscribers","params","pipeline","pipe","transformChunks","verifyEvents","source$","catchError","error","finalize","lastValueFrom","of","newMessages","events$","defaultApplyEvents","tap","event","_b","_c","onRunInitializedMutation","runSubscribersWithMutation","messages","state","from","map","onRunFailedMutation","mutation","onRunFinalizedMutation","cloned","key","value","toolCall","config","convertToLegacyEvents","HttpAgent","AbstractAgent","config","_a","structuredClone_","input","__spreadProps","__spreadValues","parameters","subscriber","httpEvents","runHttpRequest","transformHttpEventStream"],"mappings":"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","debugId":null}}]
}